CREATE QUERY rank_product(VERTEX <customer> source_customer, STRING weather, 
	STRING time_of_day, INT top_k) FOR GRAPH recommendation SYNTAX V2 { 
	/***********************************************************
	 * This query returns the top K highest rated product for a customer 
	 * while taking into account the weather and TimeOfDay.
	 *
	 * Sample Parameters:
	 * source_customer = "C001" 
	 * weather = <blank> | "GW" | "BW" 
	 * time_of_day = "T1"|"T2"|"T3"|"T4"
	 * top_k = any number > 0
	 ***********************************************************/
	
	
  	SumAccum <FLOAT> @cfAffinity;
	MaxAccum <FLOAT> @score; 
	SumAccum <UINT>  @filters=0;
	SumAccum <UINT>  @candidateFlag=0;
	UINT minFilters=0;
	
	start = {source_customer};
	
	if time_of_day!="" then minFilters = minFilters + 1; end;
	if weather!="" then minFilters = minFilters + 1; end;
	
	candidate_products = product.* ; // start with all products
	
	if minFilters!=0 THEN
	  candidate_products = 
	    SELECT p from candidate_products:p -(product_context:pc)- context:c
	    WHERE c.id==weather OR c.id==time_of_day
	    ACCUM p.@filters += 1
	    HAVING p.@filters >= minFilters;
	
	  candidate_products = 
	    SELECT p from candidate_products:p
	    POST-ACCUM p.@candidateFlag = 1; // The secret!
	END;
	
	
  features = 
	  SELECT f FROM start:s -(customer_feature:cf)- feature:f
    ACCUM f.@cfAffinity = cf.affinity; //flow affinity along edge to feature
	
	products =
	  SELECT p FROM features:f -(product_feature:pf)- product:p
	  WHERE p.@candidateFlag == 1 OR minFilters==0
    ACCUM p.@score += pf.weight*f.@cfAffinity
	  ORDER BY p.@score DESC
	  LIMIT top_k;
	
  PRINT products;
}