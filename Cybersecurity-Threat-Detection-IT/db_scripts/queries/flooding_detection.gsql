CREATE QUERY flooding_detection() FOR GRAPH MyGraph { 
/*
    Detects the addresses that flooded one service with large number of requests
    
    Starting with all IP addresses,
    (1) Get connected logins and requests 
    (2) Find the average, standard deviation, and outliers of the events
*/

    TYPEDEF TUPLE<VERTEX entity, VERTEX service, INT cnt, FLOAT mean, 
      FLOAT std> Result;
    AvgAccum @mean;
    SumAccum<FLOAT> @std;
    MapAccum<VERTEX, SumAccum<INT>> @count_map;
    ListAccum<Result> @@outlier_list;
    
    IPs = {IP.*};
  
    login_events = SELECT event 
        FROM IPs-(Has_IP)-:event
        WHERE event.Event_Type == "login"
        ACCUM event.@count_map += (IPs->1);
  
    users = SELECT user 
        FROM login_events-(User_Event)-:user
        ACCUM user.@count_map += login_events.@count_map; // add map to user
    
    events = SELECT event 
        FROM users-(User_Event:e)-:event
        WHERE event.Event_Type == "request"
        ACCUM event.@count_map += users.@count_map; // add map to event
    
    services = SELECT s 
        FROM events-(To_Service)-:s
        ACCUM s.@count_map += events.@count_map
        POST-ACCUM
            CASE WHEN s.@count_map.size() > 1 THEN
                // calculate the mean
                FOREACH (user,cnt) in s.@count_map DO
                    s.@mean += cnt
                END,
                // calculate the standard deviation
                FOREACH (user,cnt) in s.@count_map DO
                    s.@std += pow(cnt - s.@mean, 2)
                END,
                s.@std = sqrt(s.@std/(s.@count_map.size()-1)),
                CASE WHEN s.@std != 0 THEN
                    // calculate the outlier
                    FOREACH (user,cnt) in s.@count_map DO
                        CASE WHEN cnt-s.@mean > 3*s.@std THEN
                            @@outlier_list += Result(user,s,cnt,s.@mean,s.@std)
                        END
                    END
                END
            END;
  
  PRINT @@outlier_list;
  PRINT services;
}